// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comet.proto

#ifndef PROTOBUF_comet_2eproto__INCLUDED
#define PROTOBUF_comet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace eglcomet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comet_2eproto();
void protobuf_AssignDesc_comet_2eproto();
void protobuf_ShutdownFile_comet_2eproto();

class AdminLogin;
class AdminResp;
class C2SLogin;
class S2CLogin;
class OnlineStatus;
class CtrlMedia;
class SongList;
class Song;
class Msg;
class MsgQuery;
class MsgResp;
class MsgNotify;
class ReqCheckTokenByID;
class RspCheckTokenByID;
class ReqCheckRelationByID;
class RspCheckRelationByID;
class ReqPacket;
class RspPacket;
class RspRsaKey;

enum MaskCode {
  DEFAULT = 0,
  PARAMS_GZIP = 1,
  PARAMS_RSA = 2
};
bool MaskCode_IsValid(int value);
const MaskCode MaskCode_MIN = DEFAULT;
const MaskCode MaskCode_MAX = PARAMS_RSA;
const int MaskCode_ARRAYSIZE = MaskCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaskCode_descriptor();
inline const ::std::string& MaskCode_Name(MaskCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaskCode_descriptor(), value);
}
inline bool MaskCode_Parse(
    const ::std::string& name, MaskCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaskCode>(
    MaskCode_descriptor(), name, value);
}
// ===================================================================

class AdminLogin : public ::google::protobuf::Message {
 public:
  AdminLogin();
  virtual ~AdminLogin();

  AdminLogin(const AdminLogin& from);

  inline AdminLogin& operator=(const AdminLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminLogin& default_instance();

  void Swap(AdminLogin* other);

  // implements Message ----------------------------------------------

  AdminLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminLogin& from);
  void MergeFrom(const AdminLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string passwd = 2;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 2;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional string user_agent = 3;
  inline bool has_user_agent() const;
  inline void clear_user_agent();
  static const int kUserAgentFieldNumber = 3;
  inline const ::std::string& user_agent() const;
  inline void set_user_agent(const ::std::string& value);
  inline void set_user_agent(const char* value);
  inline void set_user_agent(const char* value, size_t size);
  inline ::std::string* mutable_user_agent();
  inline ::std::string* release_user_agent();
  inline void set_allocated_user_agent(::std::string* user_agent);

  // @@protoc_insertion_point(class_scope:eglcomet.AdminLogin)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_user_agent();
  inline void clear_has_user_agent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* passwd_;
  ::std::string* user_agent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static AdminLogin* default_instance_;
};
// -------------------------------------------------------------------

class AdminResp : public ::google::protobuf::Message {
 public:
  AdminResp();
  virtual ~AdminResp();

  AdminResp(const AdminResp& from);

  inline AdminResp& operator=(const AdminResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdminResp& default_instance();

  void Swap(AdminResp* other);

  // implements Message ----------------------------------------------

  AdminResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdminResp& from);
  void MergeFrom(const AdminResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eglcomet.AdminResp)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static AdminResp* default_instance_;
};
// -------------------------------------------------------------------

class C2SLogin : public ::google::protobuf::Message {
 public:
  C2SLogin();
  virtual ~C2SLogin();

  C2SLogin(const C2SLogin& from);

  inline C2SLogin& operator=(const C2SLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const C2SLogin& default_instance();

  void Swap(C2SLogin* other);

  // implements Message ----------------------------------------------

  C2SLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const C2SLogin& from);
  void MergeFrom(const C2SLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string user_agent = 3;
  inline bool has_user_agent() const;
  inline void clear_user_agent();
  static const int kUserAgentFieldNumber = 3;
  inline const ::std::string& user_agent() const;
  inline void set_user_agent(const ::std::string& value);
  inline void set_user_agent(const char* value);
  inline void set_user_agent(const char* value, size_t size);
  inline ::std::string* mutable_user_agent();
  inline ::std::string* release_user_agent();
  inline void set_allocated_user_agent(::std::string* user_agent);

  // @@protoc_insertion_point(class_scope:eglcomet.C2SLogin)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_user_agent();
  inline void clear_has_user_agent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::std::string* token_;
  ::std::string* user_agent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static C2SLogin* default_instance_;
};
// -------------------------------------------------------------------

class S2CLogin : public ::google::protobuf::Message {
 public:
  S2CLogin();
  virtual ~S2CLogin();

  S2CLogin(const S2CLogin& from);

  inline S2CLogin& operator=(const S2CLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const S2CLogin& default_instance();

  void Swap(S2CLogin* other);

  // implements Message ----------------------------------------------

  S2CLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const S2CLogin& from);
  void MergeFrom(const S2CLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // required int32 ping_time = 3;
  inline bool has_ping_time() const;
  inline void clear_ping_time();
  static const int kPingTimeFieldNumber = 3;
  inline ::google::protobuf::int32 ping_time() const;
  inline void set_ping_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eglcomet.S2CLogin)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_ping_time();
  inline void clear_has_ping_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 ping_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static S2CLogin* default_instance_;
};
// -------------------------------------------------------------------

class OnlineStatus : public ::google::protobuf::Message {
 public:
  OnlineStatus();
  virtual ~OnlineStatus();

  OnlineStatus(const OnlineStatus& from);

  inline OnlineStatus& operator=(const OnlineStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineStatus& default_instance();

  void Swap(OnlineStatus* other);

  // implements Message ----------------------------------------------

  OnlineStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineStatus& from);
  void MergeFrom(const OnlineStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string id = 1;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id(int index) const;
  inline ::std::string* mutable_id(int index);
  inline void set_id(int index, const ::std::string& value);
  inline void set_id(int index, const char* value);
  inline void set_id(int index, const char* value, size_t size);
  inline ::std::string* add_id();
  inline void add_id(const ::std::string& value);
  inline void add_id(const char* value);
  inline void add_id(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // optional bytes status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const void* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:eglcomet.OnlineStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> id_;
  ::std::string* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static OnlineStatus* default_instance_;
};
// -------------------------------------------------------------------

class CtrlMedia : public ::google::protobuf::Message {
 public:
  CtrlMedia();
  virtual ~CtrlMedia();

  CtrlMedia(const CtrlMedia& from);

  inline CtrlMedia& operator=(const CtrlMedia& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CtrlMedia& default_instance();

  void Swap(CtrlMedia* other);

  // implements Message ----------------------------------------------

  CtrlMedia* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CtrlMedia& from);
  void MergeFrom(const CtrlMedia& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // repeated string args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // optional bytes arg_bytes = 3;
  inline bool has_arg_bytes() const;
  inline void clear_arg_bytes();
  static const int kArgBytesFieldNumber = 3;
  inline const ::std::string& arg_bytes() const;
  inline void set_arg_bytes(const ::std::string& value);
  inline void set_arg_bytes(const char* value);
  inline void set_arg_bytes(const void* value, size_t size);
  inline ::std::string* mutable_arg_bytes();
  inline ::std::string* release_arg_bytes();
  inline void set_allocated_arg_bytes(::std::string* arg_bytes);

  // optional int32 seq = 4;
  inline bool has_seq() const;
  inline void clear_seq();
  static const int kSeqFieldNumber = 4;
  inline ::google::protobuf::int32 seq() const;
  inline void set_seq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eglcomet.CtrlMedia)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_arg_bytes();
  inline void clear_has_arg_bytes();
  inline void set_has_seq();
  inline void clear_has_seq();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::google::protobuf::int32 cmd_;
  ::google::protobuf::int32 seq_;
  ::std::string* arg_bytes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static CtrlMedia* default_instance_;
};
// -------------------------------------------------------------------

class SongList : public ::google::protobuf::Message {
 public:
  SongList();
  virtual ~SongList();

  SongList(const SongList& from);

  inline SongList& operator=(const SongList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SongList& default_instance();

  void Swap(SongList* other);

  // implements Message ----------------------------------------------

  SongList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SongList& from);
  void MergeFrom(const SongList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string song_list_id = 1;
  inline bool has_song_list_id() const;
  inline void clear_song_list_id();
  static const int kSongListIdFieldNumber = 1;
  inline const ::std::string& song_list_id() const;
  inline void set_song_list_id(const ::std::string& value);
  inline void set_song_list_id(const char* value);
  inline void set_song_list_id(const char* value, size_t size);
  inline ::std::string* mutable_song_list_id();
  inline ::std::string* release_song_list_id();
  inline void set_allocated_song_list_id(::std::string* song_list_id);

  // required int32 song_list_type = 2;
  inline bool has_song_list_type() const;
  inline void clear_song_list_type();
  static const int kSongListTypeFieldNumber = 2;
  inline ::google::protobuf::int32 song_list_type() const;
  inline void set_song_list_type(::google::protobuf::int32 value);

  // optional string song_list_name = 3;
  inline bool has_song_list_name() const;
  inline void clear_song_list_name();
  static const int kSongListNameFieldNumber = 3;
  inline const ::std::string& song_list_name() const;
  inline void set_song_list_name(const ::std::string& value);
  inline void set_song_list_name(const char* value);
  inline void set_song_list_name(const char* value, size_t size);
  inline ::std::string* mutable_song_list_name();
  inline ::std::string* release_song_list_name();
  inline void set_allocated_song_list_name(::std::string* song_list_name);

  // repeated .eglcomet.Song songs = 4;
  inline int songs_size() const;
  inline void clear_songs();
  static const int kSongsFieldNumber = 4;
  inline const ::eglcomet::Song& songs(int index) const;
  inline ::eglcomet::Song* mutable_songs(int index);
  inline ::eglcomet::Song* add_songs();
  inline const ::google::protobuf::RepeatedPtrField< ::eglcomet::Song >&
      songs() const;
  inline ::google::protobuf::RepeatedPtrField< ::eglcomet::Song >*
      mutable_songs();

  // @@protoc_insertion_point(class_scope:eglcomet.SongList)
 private:
  inline void set_has_song_list_id();
  inline void clear_has_song_list_id();
  inline void set_has_song_list_type();
  inline void clear_has_song_list_type();
  inline void set_has_song_list_name();
  inline void clear_has_song_list_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* song_list_id_;
  ::std::string* song_list_name_;
  ::google::protobuf::RepeatedPtrField< ::eglcomet::Song > songs_;
  ::google::protobuf::int32 song_list_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static SongList* default_instance_;
};
// -------------------------------------------------------------------

class Song : public ::google::protobuf::Message {
 public:
  Song();
  virtual ~Song();

  Song(const Song& from);

  inline Song& operator=(const Song& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Song& default_instance();

  void Swap(Song* other);

  // implements Message ----------------------------------------------

  Song* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Song& from);
  void MergeFrom(const Song& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string song_id = 1;
  inline bool has_song_id() const;
  inline void clear_song_id();
  static const int kSongIdFieldNumber = 1;
  inline const ::std::string& song_id() const;
  inline void set_song_id(const ::std::string& value);
  inline void set_song_id(const char* value);
  inline void set_song_id(const char* value, size_t size);
  inline ::std::string* mutable_song_id();
  inline ::std::string* release_song_id();
  inline void set_allocated_song_id(::std::string* song_id);

  // required string song_name = 2;
  inline bool has_song_name() const;
  inline void clear_song_name();
  static const int kSongNameFieldNumber = 2;
  inline const ::std::string& song_name() const;
  inline void set_song_name(const ::std::string& value);
  inline void set_song_name(const char* value);
  inline void set_song_name(const char* value, size_t size);
  inline ::std::string* mutable_song_name();
  inline ::std::string* release_song_name();
  inline void set_allocated_song_name(::std::string* song_name);

  // required int32 source = 3;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 3;
  inline ::google::protobuf::int32 source() const;
  inline void set_source(::google::protobuf::int32 value);

  // optional string singers = 4;
  inline bool has_singers() const;
  inline void clear_singers();
  static const int kSingersFieldNumber = 4;
  inline const ::std::string& singers() const;
  inline void set_singers(const ::std::string& value);
  inline void set_singers(const char* value);
  inline void set_singers(const char* value, size_t size);
  inline ::std::string* mutable_singers();
  inline ::std::string* release_singers();
  inline void set_allocated_singers(::std::string* singers);

  // optional string pic_url = 5;
  inline bool has_pic_url() const;
  inline void clear_pic_url();
  static const int kPicUrlFieldNumber = 5;
  inline const ::std::string& pic_url() const;
  inline void set_pic_url(const ::std::string& value);
  inline void set_pic_url(const char* value);
  inline void set_pic_url(const char* value, size_t size);
  inline ::std::string* mutable_pic_url();
  inline ::std::string* release_pic_url();
  inline void set_allocated_pic_url(::std::string* pic_url);

  // @@protoc_insertion_point(class_scope:eglcomet.Song)
 private:
  inline void set_has_song_id();
  inline void clear_has_song_id();
  inline void set_has_song_name();
  inline void clear_has_song_name();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_singers();
  inline void clear_has_singers();
  inline void set_has_pic_url();
  inline void clear_has_pic_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* song_id_;
  ::std::string* song_name_;
  ::std::string* singers_;
  ::std::string* pic_url_;
  ::google::protobuf::int32 source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static Song* default_instance_;
};
// -------------------------------------------------------------------

class Msg : public ::google::protobuf::Message {
 public:
  Msg();
  virtual ~Msg();

  Msg(const Msg& from);

  inline Msg& operator=(const Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Msg& default_instance();

  void Swap(Msg* other);

  // implements Message ----------------------------------------------

  Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Msg& from);
  void MergeFrom(const Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int64 msg_id() const;
  inline void set_msg_id(::google::protobuf::int64 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // repeated string args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::std::string& args(int index) const;
  inline ::std::string* mutable_args(int index);
  inline void set_args(int index, const ::std::string& value);
  inline void set_args(int index, const char* value);
  inline void set_args(int index, const char* value, size_t size);
  inline ::std::string* add_args();
  inline void add_args(const ::std::string& value);
  inline void add_args(const char* value);
  inline void add_args(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& args() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_args();

  // optional bytes arg_bytes = 4;
  inline bool has_arg_bytes() const;
  inline void clear_arg_bytes();
  static const int kArgBytesFieldNumber = 4;
  inline const ::std::string& arg_bytes() const;
  inline void set_arg_bytes(const ::std::string& value);
  inline void set_arg_bytes(const char* value);
  inline void set_arg_bytes(const void* value, size_t size);
  inline ::std::string* mutable_arg_bytes();
  inline ::std::string* release_arg_bytes();
  inline void set_allocated_arg_bytes(::std::string* arg_bytes);

  // optional int64 date = 5;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 5;
  inline ::google::protobuf::int64 date() const;
  inline void set_date(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:eglcomet.Msg)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_arg_bytes();
  inline void clear_has_arg_bytes();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> args_;
  ::std::string* arg_bytes_;
  ::google::protobuf::int64 date_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static Msg* default_instance_;
};
// -------------------------------------------------------------------

class MsgQuery : public ::google::protobuf::Message {
 public:
  MsgQuery();
  virtual ~MsgQuery();

  MsgQuery(const MsgQuery& from);

  inline MsgQuery& operator=(const MsgQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgQuery& default_instance();

  void Swap(MsgQuery* other);

  // implements Message ----------------------------------------------

  MsgQuery* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgQuery& from);
  void MergeFrom(const MsgQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string opt = 1;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 1;
  inline const ::std::string& opt() const;
  inline void set_opt(const ::std::string& value);
  inline void set_opt(const char* value);
  inline void set_opt(const char* value, size_t size);
  inline ::std::string* mutable_opt();
  inline ::std::string* release_opt();
  inline void set_allocated_opt(::std::string* opt);

  // @@protoc_insertion_point(class_scope:eglcomet.MsgQuery)
 private:
  inline void set_has_opt();
  inline void clear_has_opt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* opt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static MsgQuery* default_instance_;
};
// -------------------------------------------------------------------

class MsgResp : public ::google::protobuf::Message {
 public:
  MsgResp();
  virtual ~MsgResp();

  MsgResp(const MsgResp& from);

  inline MsgResp& operator=(const MsgResp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgResp& default_instance();

  void Swap(MsgResp* other);

  // implements Message ----------------------------------------------

  MsgResp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgResp& from);
  void MergeFrom(const MsgResp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::int64 msg_id() const;
  inline void set_msg_id(::google::protobuf::int64 value);

  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eglcomet.MsgResp)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 msg_id_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static MsgResp* default_instance_;
};
// -------------------------------------------------------------------

class MsgNotify : public ::google::protobuf::Message {
 public:
  MsgNotify();
  virtual ~MsgNotify();

  MsgNotify(const MsgNotify& from);

  inline MsgNotify& operator=(const MsgNotify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgNotify& default_instance();

  void Swap(MsgNotify* other);

  // implements Message ----------------------------------------------

  MsgNotify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgNotify& from);
  void MergeFrom(const MsgNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 msg_count = 1;
  inline bool has_msg_count() const;
  inline void clear_msg_count();
  static const int kMsgCountFieldNumber = 1;
  inline ::google::protobuf::int32 msg_count() const;
  inline void set_msg_count(::google::protobuf::int32 value);

  // repeated .eglcomet.Msg msg_content = 2;
  inline int msg_content_size() const;
  inline void clear_msg_content();
  static const int kMsgContentFieldNumber = 2;
  inline const ::eglcomet::Msg& msg_content(int index) const;
  inline ::eglcomet::Msg* mutable_msg_content(int index);
  inline ::eglcomet::Msg* add_msg_content();
  inline const ::google::protobuf::RepeatedPtrField< ::eglcomet::Msg >&
      msg_content() const;
  inline ::google::protobuf::RepeatedPtrField< ::eglcomet::Msg >*
      mutable_msg_content();

  // @@protoc_insertion_point(class_scope:eglcomet.MsgNotify)
 private:
  inline void set_has_msg_count();
  inline void clear_has_msg_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::eglcomet::Msg > msg_content_;
  ::google::protobuf::int32 msg_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static MsgNotify* default_instance_;
};
// -------------------------------------------------------------------

class ReqCheckTokenByID : public ::google::protobuf::Message {
 public:
  ReqCheckTokenByID();
  virtual ~ReqCheckTokenByID();

  ReqCheckTokenByID(const ReqCheckTokenByID& from);

  inline ReqCheckTokenByID& operator=(const ReqCheckTokenByID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCheckTokenByID& default_instance();

  void Swap(ReqCheckTokenByID* other);

  // implements Message ----------------------------------------------

  ReqCheckTokenByID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCheckTokenByID& from);
  void MergeFrom(const ReqCheckTokenByID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int64 id() const;
  inline void set_id(::google::protobuf::int64 value);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:eglcomet.ReqCheckTokenByID)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 id_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static ReqCheckTokenByID* default_instance_;
};
// -------------------------------------------------------------------

class RspCheckTokenByID : public ::google::protobuf::Message {
 public:
  RspCheckTokenByID();
  virtual ~RspCheckTokenByID();

  RspCheckTokenByID(const RspCheckTokenByID& from);

  inline RspCheckTokenByID& operator=(const RspCheckTokenByID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspCheckTokenByID& default_instance();

  void Swap(RspCheckTokenByID* other);

  // implements Message ----------------------------------------------

  RspCheckTokenByID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspCheckTokenByID& from);
  void MergeFrom(const RspCheckTokenByID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rescode = 1;
  inline bool has_rescode() const;
  inline void clear_rescode();
  static const int kRescodeFieldNumber = 1;
  inline ::google::protobuf::int32 rescode() const;
  inline void set_rescode(::google::protobuf::int32 value);

  // required string resmsg = 2;
  inline bool has_resmsg() const;
  inline void clear_resmsg();
  static const int kResmsgFieldNumber = 2;
  inline const ::std::string& resmsg() const;
  inline void set_resmsg(const ::std::string& value);
  inline void set_resmsg(const char* value);
  inline void set_resmsg(const char* value, size_t size);
  inline ::std::string* mutable_resmsg();
  inline ::std::string* release_resmsg();
  inline void set_allocated_resmsg(::std::string* resmsg);

  // @@protoc_insertion_point(class_scope:eglcomet.RspCheckTokenByID)
 private:
  inline void set_has_rescode();
  inline void clear_has_rescode();
  inline void set_has_resmsg();
  inline void clear_has_resmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* resmsg_;
  ::google::protobuf::int32 rescode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static RspCheckTokenByID* default_instance_;
};
// -------------------------------------------------------------------

class ReqCheckRelationByID : public ::google::protobuf::Message {
 public:
  ReqCheckRelationByID();
  virtual ~ReqCheckRelationByID();

  ReqCheckRelationByID(const ReqCheckRelationByID& from);

  inline ReqCheckRelationByID& operator=(const ReqCheckRelationByID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCheckRelationByID& default_instance();

  void Swap(ReqCheckRelationByID* other);

  // implements Message ----------------------------------------------

  ReqCheckRelationByID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCheckRelationByID& from);
  void MergeFrom(const ReqCheckRelationByID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 fromID = 1;
  inline bool has_fromid() const;
  inline void clear_fromid();
  static const int kFromIDFieldNumber = 1;
  inline ::google::protobuf::int64 fromid() const;
  inline void set_fromid(::google::protobuf::int64 value);

  // required int64 toID = 2;
  inline bool has_toid() const;
  inline void clear_toid();
  static const int kToIDFieldNumber = 2;
  inline ::google::protobuf::int64 toid() const;
  inline void set_toid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:eglcomet.ReqCheckRelationByID)
 private:
  inline void set_has_fromid();
  inline void clear_has_fromid();
  inline void set_has_toid();
  inline void clear_has_toid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 fromid_;
  ::google::protobuf::int64 toid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static ReqCheckRelationByID* default_instance_;
};
// -------------------------------------------------------------------

class RspCheckRelationByID : public ::google::protobuf::Message {
 public:
  RspCheckRelationByID();
  virtual ~RspCheckRelationByID();

  RspCheckRelationByID(const RspCheckRelationByID& from);

  inline RspCheckRelationByID& operator=(const RspCheckRelationByID& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspCheckRelationByID& default_instance();

  void Swap(RspCheckRelationByID* other);

  // implements Message ----------------------------------------------

  RspCheckRelationByID* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspCheckRelationByID& from);
  void MergeFrom(const RspCheckRelationByID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rescode = 1;
  inline bool has_rescode() const;
  inline void clear_rescode();
  static const int kRescodeFieldNumber = 1;
  inline ::google::protobuf::int32 rescode() const;
  inline void set_rescode(::google::protobuf::int32 value);

  // required string resmsg = 2;
  inline bool has_resmsg() const;
  inline void clear_resmsg();
  static const int kResmsgFieldNumber = 2;
  inline const ::std::string& resmsg() const;
  inline void set_resmsg(const ::std::string& value);
  inline void set_resmsg(const char* value);
  inline void set_resmsg(const char* value, size_t size);
  inline ::std::string* mutable_resmsg();
  inline ::std::string* release_resmsg();
  inline void set_allocated_resmsg(::std::string* resmsg);

  // @@protoc_insertion_point(class_scope:eglcomet.RspCheckRelationByID)
 private:
  inline void set_has_rescode();
  inline void clear_has_rescode();
  inline void set_has_resmsg();
  inline void clear_has_resmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* resmsg_;
  ::google::protobuf::int32 rescode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static RspCheckRelationByID* default_instance_;
};
// -------------------------------------------------------------------

class ReqPacket : public ::google::protobuf::Message {
 public:
  ReqPacket();
  virtual ~ReqPacket();

  ReqPacket(const ReqPacket& from);

  inline ReqPacket& operator=(const ReqPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPacket& default_instance();

  void Swap(ReqPacket* other);

  // implements Message ----------------------------------------------

  ReqPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqPacket& from);
  void MergeFrom(const ReqPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mask = 1;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 1;
  inline ::google::protobuf::int32 mask() const;
  inline void set_mask(::google::protobuf::int32 value);

  // required string udi = 2;
  inline bool has_udi() const;
  inline void clear_udi();
  static const int kUdiFieldNumber = 2;
  inline const ::std::string& udi() const;
  inline void set_udi(const ::std::string& value);
  inline void set_udi(const char* value);
  inline void set_udi(const char* value, size_t size);
  inline ::std::string* mutable_udi();
  inline ::std::string* release_udi();
  inline void set_allocated_udi(::std::string* udi);

  // repeated string action = 3;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline const ::std::string& action(int index) const;
  inline ::std::string* mutable_action(int index);
  inline void set_action(int index, const ::std::string& value);
  inline void set_action(int index, const char* value);
  inline void set_action(int index, const char* value, size_t size);
  inline ::std::string* add_action();
  inline void add_action(const ::std::string& value);
  inline void add_action(const char* value);
  inline void add_action(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& action() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_action();

  // repeated bytes params = 4;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 4;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const void* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // required int32 reqNo = 5;
  inline bool has_reqno() const;
  inline void clear_reqno();
  static const int kReqNoFieldNumber = 5;
  inline ::google::protobuf::int32 reqno() const;
  inline void set_reqno(::google::protobuf::int32 value);

  // optional int32 chnNo = 6;
  inline bool has_chnno() const;
  inline void clear_chnno();
  static const int kChnNoFieldNumber = 6;
  inline ::google::protobuf::int32 chnno() const;
  inline void set_chnno(::google::protobuf::int32 value);

  // optional int32 chnPos = 7;
  inline bool has_chnpos() const;
  inline void clear_chnpos();
  static const int kChnPosFieldNumber = 7;
  inline ::google::protobuf::int32 chnpos() const;
  inline void set_chnpos(::google::protobuf::int32 value);

  // required int32 clientId = 8;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIdFieldNumber = 8;
  inline ::google::protobuf::int32 clientid() const;
  inline void set_clientid(::google::protobuf::int32 value);

  // optional int32 clientPos = 9;
  inline bool has_clientpos() const;
  inline void clear_clientpos();
  static const int kClientPosFieldNumber = 9;
  inline ::google::protobuf::int32 clientpos() const;
  inline void set_clientpos(::google::protobuf::int32 value);

  // optional string clientVer = 10;
  inline bool has_clientver() const;
  inline void clear_clientver();
  static const int kClientVerFieldNumber = 10;
  inline const ::std::string& clientver() const;
  inline void set_clientver(const ::std::string& value);
  inline void set_clientver(const char* value);
  inline void set_clientver(const char* value, size_t size);
  inline ::std::string* mutable_clientver();
  inline ::std::string* release_clientver();
  inline void set_allocated_clientver(::std::string* clientver);

  // optional string rsaKeyVer = 11;
  inline bool has_rsakeyver() const;
  inline void clear_rsakeyver();
  static const int kRsaKeyVerFieldNumber = 11;
  inline const ::std::string& rsakeyver() const;
  inline void set_rsakeyver(const ::std::string& value);
  inline void set_rsakeyver(const char* value);
  inline void set_rsakeyver(const char* value, size_t size);
  inline ::std::string* mutable_rsakeyver();
  inline ::std::string* release_rsakeyver();
  inline void set_allocated_rsakeyver(::std::string* rsakeyver);

  // @@protoc_insertion_point(class_scope:eglcomet.ReqPacket)
 private:
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_udi();
  inline void clear_has_udi();
  inline void set_has_reqno();
  inline void clear_has_reqno();
  inline void set_has_chnno();
  inline void clear_has_chnno();
  inline void set_has_chnpos();
  inline void clear_has_chnpos();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_clientpos();
  inline void clear_has_clientpos();
  inline void set_has_clientver();
  inline void clear_has_clientver();
  inline void set_has_rsakeyver();
  inline void clear_has_rsakeyver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* udi_;
  ::google::protobuf::RepeatedPtrField< ::std::string> action_;
  ::google::protobuf::int32 mask_;
  ::google::protobuf::int32 reqno_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::google::protobuf::int32 chnno_;
  ::google::protobuf::int32 chnpos_;
  ::google::protobuf::int32 clientid_;
  ::google::protobuf::int32 clientpos_;
  ::std::string* clientver_;
  ::std::string* rsakeyver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static ReqPacket* default_instance_;
};
// -------------------------------------------------------------------

class RspPacket : public ::google::protobuf::Message {
 public:
  RspPacket();
  virtual ~RspPacket();

  RspPacket(const RspPacket& from);

  inline RspPacket& operator=(const RspPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspPacket& default_instance();

  void Swap(RspPacket* other);

  // implements Message ----------------------------------------------

  RspPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspPacket& from);
  void MergeFrom(const RspPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mask = 1;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 1;
  inline ::google::protobuf::int32 mask() const;
  inline void set_mask(::google::protobuf::int32 value);

  // required int32 rescode = 2;
  inline bool has_rescode() const;
  inline void clear_rescode();
  static const int kRescodeFieldNumber = 2;
  inline ::google::protobuf::int32 rescode() const;
  inline void set_rescode(::google::protobuf::int32 value);

  // required string resmsg = 3;
  inline bool has_resmsg() const;
  inline void clear_resmsg();
  static const int kResmsgFieldNumber = 3;
  inline const ::std::string& resmsg() const;
  inline void set_resmsg(const ::std::string& value);
  inline void set_resmsg(const char* value);
  inline void set_resmsg(const char* value, size_t size);
  inline ::std::string* mutable_resmsg();
  inline ::std::string* release_resmsg();
  inline void set_allocated_resmsg(::std::string* resmsg);

  // repeated string action = 4;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline const ::std::string& action(int index) const;
  inline ::std::string* mutable_action(int index);
  inline void set_action(int index, const ::std::string& value);
  inline void set_action(int index, const char* value);
  inline void set_action(int index, const char* value, size_t size);
  inline ::std::string* add_action();
  inline void add_action(const ::std::string& value);
  inline void add_action(const char* value);
  inline void add_action(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& action() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_action();

  // repeated bytes params = 5;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 5;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const void* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // @@protoc_insertion_point(class_scope:eglcomet.RspPacket)
 private:
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_rescode();
  inline void clear_has_rescode();
  inline void set_has_resmsg();
  inline void clear_has_resmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mask_;
  ::google::protobuf::int32 rescode_;
  ::std::string* resmsg_;
  ::google::protobuf::RepeatedPtrField< ::std::string> action_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static RspPacket* default_instance_;
};
// -------------------------------------------------------------------

class RspRsaKey : public ::google::protobuf::Message {
 public:
  RspRsaKey();
  virtual ~RspRsaKey();

  RspRsaKey(const RspRsaKey& from);

  inline RspRsaKey& operator=(const RspRsaKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RspRsaKey& default_instance();

  void Swap(RspRsaKey* other);

  // implements Message ----------------------------------------------

  RspRsaKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RspRsaKey& from);
  void MergeFrom(const RspRsaKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string rsaVer = 1;
  inline bool has_rsaver() const;
  inline void clear_rsaver();
  static const int kRsaVerFieldNumber = 1;
  inline const ::std::string& rsaver() const;
  inline void set_rsaver(const ::std::string& value);
  inline void set_rsaver(const char* value);
  inline void set_rsaver(const char* value, size_t size);
  inline ::std::string* mutable_rsaver();
  inline ::std::string* release_rsaver();
  inline void set_allocated_rsaver(::std::string* rsaver);

  // required string rsaKey = 2;
  inline bool has_rsakey() const;
  inline void clear_rsakey();
  static const int kRsaKeyFieldNumber = 2;
  inline const ::std::string& rsakey() const;
  inline void set_rsakey(const ::std::string& value);
  inline void set_rsakey(const char* value);
  inline void set_rsakey(const char* value, size_t size);
  inline ::std::string* mutable_rsakey();
  inline ::std::string* release_rsakey();
  inline void set_allocated_rsakey(::std::string* rsakey);

  // @@protoc_insertion_point(class_scope:eglcomet.RspRsaKey)
 private:
  inline void set_has_rsaver();
  inline void clear_has_rsaver();
  inline void set_has_rsakey();
  inline void clear_has_rsakey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rsaver_;
  ::std::string* rsakey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_comet_2eproto();
  friend void protobuf_AssignDesc_comet_2eproto();
  friend void protobuf_ShutdownFile_comet_2eproto();

  void InitAsDefaultInstance();
  static RspRsaKey* default_instance_;
};
// ===================================================================


// ===================================================================

// AdminLogin

// required string id = 1;
inline bool AdminLogin::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminLogin::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminLogin::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminLogin::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& AdminLogin::id() const {
  return *id_;
}
inline void AdminLogin::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AdminLogin::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void AdminLogin::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminLogin::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* AdminLogin::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdminLogin::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string passwd = 2;
inline bool AdminLogin::has_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminLogin::set_has_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminLogin::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminLogin::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& AdminLogin::passwd() const {
  return *passwd_;
}
inline void AdminLogin::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void AdminLogin::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void AdminLogin::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminLogin::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* AdminLogin::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdminLogin::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_agent = 3;
inline bool AdminLogin::has_user_agent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdminLogin::set_has_user_agent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdminLogin::clear_has_user_agent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdminLogin::clear_user_agent() {
  if (user_agent_ != &::google::protobuf::internal::kEmptyString) {
    user_agent_->clear();
  }
  clear_has_user_agent();
}
inline const ::std::string& AdminLogin::user_agent() const {
  return *user_agent_;
}
inline void AdminLogin::set_user_agent(const ::std::string& value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
}
inline void AdminLogin::set_user_agent(const char* value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
}
inline void AdminLogin::set_user_agent(const char* value, size_t size) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminLogin::mutable_user_agent() {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  return user_agent_;
}
inline ::std::string* AdminLogin::release_user_agent() {
  clear_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_agent_;
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdminLogin::set_allocated_user_agent(::std::string* user_agent) {
  if (user_agent_ != &::google::protobuf::internal::kEmptyString) {
    delete user_agent_;
  }
  if (user_agent) {
    set_has_user_agent();
    user_agent_ = user_agent;
  } else {
    clear_has_user_agent();
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AdminResp

// required int32 code = 1;
inline bool AdminResp::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdminResp::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdminResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdminResp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 AdminResp::code() const {
  return code_;
}
inline void AdminResp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string msg = 2;
inline bool AdminResp::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdminResp::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdminResp::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdminResp::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& AdminResp::msg() const {
  return *msg_;
}
inline void AdminResp::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void AdminResp::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void AdminResp::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdminResp::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* AdminResp::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdminResp::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool AdminResp::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdminResp::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdminResp::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdminResp::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 AdminResp::port() const {
  return port_;
}
inline void AdminResp::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// C2SLogin

// required int64 id = 1;
inline bool C2SLogin::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void C2SLogin::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void C2SLogin::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void C2SLogin::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 C2SLogin::id() const {
  return id_;
}
inline void C2SLogin::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required string token = 2;
inline bool C2SLogin::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void C2SLogin::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void C2SLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void C2SLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& C2SLogin::token() const {
  return *token_;
}
inline void C2SLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void C2SLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void C2SLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* C2SLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void C2SLogin::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user_agent = 3;
inline bool C2SLogin::has_user_agent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void C2SLogin::set_has_user_agent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void C2SLogin::clear_has_user_agent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void C2SLogin::clear_user_agent() {
  if (user_agent_ != &::google::protobuf::internal::kEmptyString) {
    user_agent_->clear();
  }
  clear_has_user_agent();
}
inline const ::std::string& C2SLogin::user_agent() const {
  return *user_agent_;
}
inline void C2SLogin::set_user_agent(const ::std::string& value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
}
inline void C2SLogin::set_user_agent(const char* value) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(value);
}
inline void C2SLogin::set_user_agent(const char* value, size_t size) {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  user_agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* C2SLogin::mutable_user_agent() {
  set_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    user_agent_ = new ::std::string;
  }
  return user_agent_;
}
inline ::std::string* C2SLogin::release_user_agent() {
  clear_has_user_agent();
  if (user_agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_agent_;
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void C2SLogin::set_allocated_user_agent(::std::string* user_agent) {
  if (user_agent_ != &::google::protobuf::internal::kEmptyString) {
    delete user_agent_;
  }
  if (user_agent) {
    set_has_user_agent();
    user_agent_ = user_agent;
  } else {
    clear_has_user_agent();
    user_agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// S2CLogin

// required int32 code = 1;
inline bool S2CLogin::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void S2CLogin::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void S2CLogin::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void S2CLogin::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 S2CLogin::code() const {
  return code_;
}
inline void S2CLogin::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional string msg = 2;
inline bool S2CLogin::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void S2CLogin::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void S2CLogin::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void S2CLogin::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& S2CLogin::msg() const {
  return *msg_;
}
inline void S2CLogin::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void S2CLogin::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void S2CLogin::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* S2CLogin::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* S2CLogin::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void S2CLogin::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 ping_time = 3;
inline bool S2CLogin::has_ping_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void S2CLogin::set_has_ping_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void S2CLogin::clear_has_ping_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void S2CLogin::clear_ping_time() {
  ping_time_ = 0;
  clear_has_ping_time();
}
inline ::google::protobuf::int32 S2CLogin::ping_time() const {
  return ping_time_;
}
inline void S2CLogin::set_ping_time(::google::protobuf::int32 value) {
  set_has_ping_time();
  ping_time_ = value;
}

// -------------------------------------------------------------------

// OnlineStatus

// repeated string id = 1;
inline int OnlineStatus::id_size() const {
  return id_.size();
}
inline void OnlineStatus::clear_id() {
  id_.Clear();
}
inline const ::std::string& OnlineStatus::id(int index) const {
  return id_.Get(index);
}
inline ::std::string* OnlineStatus::mutable_id(int index) {
  return id_.Mutable(index);
}
inline void OnlineStatus::set_id(int index, const ::std::string& value) {
  id_.Mutable(index)->assign(value);
}
inline void OnlineStatus::set_id(int index, const char* value) {
  id_.Mutable(index)->assign(value);
}
inline void OnlineStatus::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnlineStatus::add_id() {
  return id_.Add();
}
inline void OnlineStatus::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
}
inline void OnlineStatus::add_id(const char* value) {
  id_.Add()->assign(value);
}
inline void OnlineStatus::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OnlineStatus::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OnlineStatus::mutable_id() {
  return &id_;
}

// optional bytes status = 2;
inline bool OnlineStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineStatus::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& OnlineStatus::status() const {
  return *status_;
}
inline void OnlineStatus::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void OnlineStatus::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void OnlineStatus::set_status(const void* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnlineStatus::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* OnlineStatus::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OnlineStatus::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CtrlMedia

// required int32 cmd = 1;
inline bool CtrlMedia::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CtrlMedia::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CtrlMedia::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CtrlMedia::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 CtrlMedia::cmd() const {
  return cmd_;
}
inline void CtrlMedia::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
}

// repeated string args = 2;
inline int CtrlMedia::args_size() const {
  return args_.size();
}
inline void CtrlMedia::clear_args() {
  args_.Clear();
}
inline const ::std::string& CtrlMedia::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* CtrlMedia::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void CtrlMedia::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void CtrlMedia::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void CtrlMedia::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CtrlMedia::add_args() {
  return args_.Add();
}
inline void CtrlMedia::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void CtrlMedia::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void CtrlMedia::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CtrlMedia::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CtrlMedia::mutable_args() {
  return &args_;
}

// optional bytes arg_bytes = 3;
inline bool CtrlMedia::has_arg_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CtrlMedia::set_has_arg_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CtrlMedia::clear_has_arg_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CtrlMedia::clear_arg_bytes() {
  if (arg_bytes_ != &::google::protobuf::internal::kEmptyString) {
    arg_bytes_->clear();
  }
  clear_has_arg_bytes();
}
inline const ::std::string& CtrlMedia::arg_bytes() const {
  return *arg_bytes_;
}
inline void CtrlMedia::set_arg_bytes(const ::std::string& value) {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  arg_bytes_->assign(value);
}
inline void CtrlMedia::set_arg_bytes(const char* value) {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  arg_bytes_->assign(value);
}
inline void CtrlMedia::set_arg_bytes(const void* value, size_t size) {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  arg_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CtrlMedia::mutable_arg_bytes() {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  return arg_bytes_;
}
inline ::std::string* CtrlMedia::release_arg_bytes() {
  clear_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arg_bytes_;
    arg_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CtrlMedia::set_allocated_arg_bytes(::std::string* arg_bytes) {
  if (arg_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete arg_bytes_;
  }
  if (arg_bytes) {
    set_has_arg_bytes();
    arg_bytes_ = arg_bytes;
  } else {
    clear_has_arg_bytes();
    arg_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 seq = 4;
inline bool CtrlMedia::has_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CtrlMedia::set_has_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CtrlMedia::clear_has_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CtrlMedia::clear_seq() {
  seq_ = 0;
  clear_has_seq();
}
inline ::google::protobuf::int32 CtrlMedia::seq() const {
  return seq_;
}
inline void CtrlMedia::set_seq(::google::protobuf::int32 value) {
  set_has_seq();
  seq_ = value;
}

// -------------------------------------------------------------------

// SongList

// required string song_list_id = 1;
inline bool SongList::has_song_list_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SongList::set_has_song_list_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SongList::clear_has_song_list_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SongList::clear_song_list_id() {
  if (song_list_id_ != &::google::protobuf::internal::kEmptyString) {
    song_list_id_->clear();
  }
  clear_has_song_list_id();
}
inline const ::std::string& SongList::song_list_id() const {
  return *song_list_id_;
}
inline void SongList::set_song_list_id(const ::std::string& value) {
  set_has_song_list_id();
  if (song_list_id_ == &::google::protobuf::internal::kEmptyString) {
    song_list_id_ = new ::std::string;
  }
  song_list_id_->assign(value);
}
inline void SongList::set_song_list_id(const char* value) {
  set_has_song_list_id();
  if (song_list_id_ == &::google::protobuf::internal::kEmptyString) {
    song_list_id_ = new ::std::string;
  }
  song_list_id_->assign(value);
}
inline void SongList::set_song_list_id(const char* value, size_t size) {
  set_has_song_list_id();
  if (song_list_id_ == &::google::protobuf::internal::kEmptyString) {
    song_list_id_ = new ::std::string;
  }
  song_list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongList::mutable_song_list_id() {
  set_has_song_list_id();
  if (song_list_id_ == &::google::protobuf::internal::kEmptyString) {
    song_list_id_ = new ::std::string;
  }
  return song_list_id_;
}
inline ::std::string* SongList::release_song_list_id() {
  clear_has_song_list_id();
  if (song_list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = song_list_id_;
    song_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SongList::set_allocated_song_list_id(::std::string* song_list_id) {
  if (song_list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete song_list_id_;
  }
  if (song_list_id) {
    set_has_song_list_id();
    song_list_id_ = song_list_id;
  } else {
    clear_has_song_list_id();
    song_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 song_list_type = 2;
inline bool SongList::has_song_list_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SongList::set_has_song_list_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SongList::clear_has_song_list_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SongList::clear_song_list_type() {
  song_list_type_ = 0;
  clear_has_song_list_type();
}
inline ::google::protobuf::int32 SongList::song_list_type() const {
  return song_list_type_;
}
inline void SongList::set_song_list_type(::google::protobuf::int32 value) {
  set_has_song_list_type();
  song_list_type_ = value;
}

// optional string song_list_name = 3;
inline bool SongList::has_song_list_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SongList::set_has_song_list_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SongList::clear_has_song_list_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SongList::clear_song_list_name() {
  if (song_list_name_ != &::google::protobuf::internal::kEmptyString) {
    song_list_name_->clear();
  }
  clear_has_song_list_name();
}
inline const ::std::string& SongList::song_list_name() const {
  return *song_list_name_;
}
inline void SongList::set_song_list_name(const ::std::string& value) {
  set_has_song_list_name();
  if (song_list_name_ == &::google::protobuf::internal::kEmptyString) {
    song_list_name_ = new ::std::string;
  }
  song_list_name_->assign(value);
}
inline void SongList::set_song_list_name(const char* value) {
  set_has_song_list_name();
  if (song_list_name_ == &::google::protobuf::internal::kEmptyString) {
    song_list_name_ = new ::std::string;
  }
  song_list_name_->assign(value);
}
inline void SongList::set_song_list_name(const char* value, size_t size) {
  set_has_song_list_name();
  if (song_list_name_ == &::google::protobuf::internal::kEmptyString) {
    song_list_name_ = new ::std::string;
  }
  song_list_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SongList::mutable_song_list_name() {
  set_has_song_list_name();
  if (song_list_name_ == &::google::protobuf::internal::kEmptyString) {
    song_list_name_ = new ::std::string;
  }
  return song_list_name_;
}
inline ::std::string* SongList::release_song_list_name() {
  clear_has_song_list_name();
  if (song_list_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = song_list_name_;
    song_list_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SongList::set_allocated_song_list_name(::std::string* song_list_name) {
  if (song_list_name_ != &::google::protobuf::internal::kEmptyString) {
    delete song_list_name_;
  }
  if (song_list_name) {
    set_has_song_list_name();
    song_list_name_ = song_list_name;
  } else {
    clear_has_song_list_name();
    song_list_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .eglcomet.Song songs = 4;
inline int SongList::songs_size() const {
  return songs_.size();
}
inline void SongList::clear_songs() {
  songs_.Clear();
}
inline const ::eglcomet::Song& SongList::songs(int index) const {
  return songs_.Get(index);
}
inline ::eglcomet::Song* SongList::mutable_songs(int index) {
  return songs_.Mutable(index);
}
inline ::eglcomet::Song* SongList::add_songs() {
  return songs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eglcomet::Song >&
SongList::songs() const {
  return songs_;
}
inline ::google::protobuf::RepeatedPtrField< ::eglcomet::Song >*
SongList::mutable_songs() {
  return &songs_;
}

// -------------------------------------------------------------------

// Song

// required string song_id = 1;
inline bool Song::has_song_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Song::set_has_song_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Song::clear_has_song_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Song::clear_song_id() {
  if (song_id_ != &::google::protobuf::internal::kEmptyString) {
    song_id_->clear();
  }
  clear_has_song_id();
}
inline const ::std::string& Song::song_id() const {
  return *song_id_;
}
inline void Song::set_song_id(const ::std::string& value) {
  set_has_song_id();
  if (song_id_ == &::google::protobuf::internal::kEmptyString) {
    song_id_ = new ::std::string;
  }
  song_id_->assign(value);
}
inline void Song::set_song_id(const char* value) {
  set_has_song_id();
  if (song_id_ == &::google::protobuf::internal::kEmptyString) {
    song_id_ = new ::std::string;
  }
  song_id_->assign(value);
}
inline void Song::set_song_id(const char* value, size_t size) {
  set_has_song_id();
  if (song_id_ == &::google::protobuf::internal::kEmptyString) {
    song_id_ = new ::std::string;
  }
  song_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Song::mutable_song_id() {
  set_has_song_id();
  if (song_id_ == &::google::protobuf::internal::kEmptyString) {
    song_id_ = new ::std::string;
  }
  return song_id_;
}
inline ::std::string* Song::release_song_id() {
  clear_has_song_id();
  if (song_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = song_id_;
    song_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Song::set_allocated_song_id(::std::string* song_id) {
  if (song_id_ != &::google::protobuf::internal::kEmptyString) {
    delete song_id_;
  }
  if (song_id) {
    set_has_song_id();
    song_id_ = song_id;
  } else {
    clear_has_song_id();
    song_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string song_name = 2;
inline bool Song::has_song_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Song::set_has_song_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Song::clear_has_song_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Song::clear_song_name() {
  if (song_name_ != &::google::protobuf::internal::kEmptyString) {
    song_name_->clear();
  }
  clear_has_song_name();
}
inline const ::std::string& Song::song_name() const {
  return *song_name_;
}
inline void Song::set_song_name(const ::std::string& value) {
  set_has_song_name();
  if (song_name_ == &::google::protobuf::internal::kEmptyString) {
    song_name_ = new ::std::string;
  }
  song_name_->assign(value);
}
inline void Song::set_song_name(const char* value) {
  set_has_song_name();
  if (song_name_ == &::google::protobuf::internal::kEmptyString) {
    song_name_ = new ::std::string;
  }
  song_name_->assign(value);
}
inline void Song::set_song_name(const char* value, size_t size) {
  set_has_song_name();
  if (song_name_ == &::google::protobuf::internal::kEmptyString) {
    song_name_ = new ::std::string;
  }
  song_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Song::mutable_song_name() {
  set_has_song_name();
  if (song_name_ == &::google::protobuf::internal::kEmptyString) {
    song_name_ = new ::std::string;
  }
  return song_name_;
}
inline ::std::string* Song::release_song_name() {
  clear_has_song_name();
  if (song_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = song_name_;
    song_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Song::set_allocated_song_name(::std::string* song_name) {
  if (song_name_ != &::google::protobuf::internal::kEmptyString) {
    delete song_name_;
  }
  if (song_name) {
    set_has_song_name();
    song_name_ = song_name;
  } else {
    clear_has_song_name();
    song_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 source = 3;
inline bool Song::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Song::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Song::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Song::clear_source() {
  source_ = 0;
  clear_has_source();
}
inline ::google::protobuf::int32 Song::source() const {
  return source_;
}
inline void Song::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
}

// optional string singers = 4;
inline bool Song::has_singers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Song::set_has_singers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Song::clear_has_singers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Song::clear_singers() {
  if (singers_ != &::google::protobuf::internal::kEmptyString) {
    singers_->clear();
  }
  clear_has_singers();
}
inline const ::std::string& Song::singers() const {
  return *singers_;
}
inline void Song::set_singers(const ::std::string& value) {
  set_has_singers();
  if (singers_ == &::google::protobuf::internal::kEmptyString) {
    singers_ = new ::std::string;
  }
  singers_->assign(value);
}
inline void Song::set_singers(const char* value) {
  set_has_singers();
  if (singers_ == &::google::protobuf::internal::kEmptyString) {
    singers_ = new ::std::string;
  }
  singers_->assign(value);
}
inline void Song::set_singers(const char* value, size_t size) {
  set_has_singers();
  if (singers_ == &::google::protobuf::internal::kEmptyString) {
    singers_ = new ::std::string;
  }
  singers_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Song::mutable_singers() {
  set_has_singers();
  if (singers_ == &::google::protobuf::internal::kEmptyString) {
    singers_ = new ::std::string;
  }
  return singers_;
}
inline ::std::string* Song::release_singers() {
  clear_has_singers();
  if (singers_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = singers_;
    singers_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Song::set_allocated_singers(::std::string* singers) {
  if (singers_ != &::google::protobuf::internal::kEmptyString) {
    delete singers_;
  }
  if (singers) {
    set_has_singers();
    singers_ = singers;
  } else {
    clear_has_singers();
    singers_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pic_url = 5;
inline bool Song::has_pic_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Song::set_has_pic_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Song::clear_has_pic_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Song::clear_pic_url() {
  if (pic_url_ != &::google::protobuf::internal::kEmptyString) {
    pic_url_->clear();
  }
  clear_has_pic_url();
}
inline const ::std::string& Song::pic_url() const {
  return *pic_url_;
}
inline void Song::set_pic_url(const ::std::string& value) {
  set_has_pic_url();
  if (pic_url_ == &::google::protobuf::internal::kEmptyString) {
    pic_url_ = new ::std::string;
  }
  pic_url_->assign(value);
}
inline void Song::set_pic_url(const char* value) {
  set_has_pic_url();
  if (pic_url_ == &::google::protobuf::internal::kEmptyString) {
    pic_url_ = new ::std::string;
  }
  pic_url_->assign(value);
}
inline void Song::set_pic_url(const char* value, size_t size) {
  set_has_pic_url();
  if (pic_url_ == &::google::protobuf::internal::kEmptyString) {
    pic_url_ = new ::std::string;
  }
  pic_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Song::mutable_pic_url() {
  set_has_pic_url();
  if (pic_url_ == &::google::protobuf::internal::kEmptyString) {
    pic_url_ = new ::std::string;
  }
  return pic_url_;
}
inline ::std::string* Song::release_pic_url() {
  clear_has_pic_url();
  if (pic_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pic_url_;
    pic_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Song::set_allocated_pic_url(::std::string* pic_url) {
  if (pic_url_ != &::google::protobuf::internal::kEmptyString) {
    delete pic_url_;
  }
  if (pic_url) {
    set_has_pic_url();
    pic_url_ = pic_url;
  } else {
    clear_has_pic_url();
    pic_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Msg

// required int64 msg_id = 1;
inline bool Msg::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Msg::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Msg::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Msg::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::int64 Msg::msg_id() const {
  return msg_id_;
}
inline void Msg::set_msg_id(::google::protobuf::int64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// required int32 type = 2;
inline bool Msg::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Msg::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Msg::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Msg::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Msg::type() const {
  return type_;
}
inline void Msg::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated string args = 3;
inline int Msg::args_size() const {
  return args_.size();
}
inline void Msg::clear_args() {
  args_.Clear();
}
inline const ::std::string& Msg::args(int index) const {
  return args_.Get(index);
}
inline ::std::string* Msg::mutable_args(int index) {
  return args_.Mutable(index);
}
inline void Msg::set_args(int index, const ::std::string& value) {
  args_.Mutable(index)->assign(value);
}
inline void Msg::set_args(int index, const char* value) {
  args_.Mutable(index)->assign(value);
}
inline void Msg::set_args(int index, const char* value, size_t size) {
  args_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg::add_args() {
  return args_.Add();
}
inline void Msg::add_args(const ::std::string& value) {
  args_.Add()->assign(value);
}
inline void Msg::add_args(const char* value) {
  args_.Add()->assign(value);
}
inline void Msg::add_args(const char* value, size_t size) {
  args_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Msg::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Msg::mutable_args() {
  return &args_;
}

// optional bytes arg_bytes = 4;
inline bool Msg::has_arg_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Msg::set_has_arg_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Msg::clear_has_arg_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Msg::clear_arg_bytes() {
  if (arg_bytes_ != &::google::protobuf::internal::kEmptyString) {
    arg_bytes_->clear();
  }
  clear_has_arg_bytes();
}
inline const ::std::string& Msg::arg_bytes() const {
  return *arg_bytes_;
}
inline void Msg::set_arg_bytes(const ::std::string& value) {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  arg_bytes_->assign(value);
}
inline void Msg::set_arg_bytes(const char* value) {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  arg_bytes_->assign(value);
}
inline void Msg::set_arg_bytes(const void* value, size_t size) {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  arg_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Msg::mutable_arg_bytes() {
  set_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    arg_bytes_ = new ::std::string;
  }
  return arg_bytes_;
}
inline ::std::string* Msg::release_arg_bytes() {
  clear_has_arg_bytes();
  if (arg_bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arg_bytes_;
    arg_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Msg::set_allocated_arg_bytes(::std::string* arg_bytes) {
  if (arg_bytes_ != &::google::protobuf::internal::kEmptyString) {
    delete arg_bytes_;
  }
  if (arg_bytes) {
    set_has_arg_bytes();
    arg_bytes_ = arg_bytes;
  } else {
    clear_has_arg_bytes();
    arg_bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 date = 5;
inline bool Msg::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Msg::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Msg::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Msg::clear_date() {
  date_ = GOOGLE_LONGLONG(0);
  clear_has_date();
}
inline ::google::protobuf::int64 Msg::date() const {
  return date_;
}
inline void Msg::set_date(::google::protobuf::int64 value) {
  set_has_date();
  date_ = value;
}

// -------------------------------------------------------------------

// MsgQuery

// optional string opt = 1;
inline bool MsgQuery::has_opt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgQuery::set_has_opt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgQuery::clear_has_opt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgQuery::clear_opt() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    opt_->clear();
  }
  clear_has_opt();
}
inline const ::std::string& MsgQuery::opt() const {
  return *opt_;
}
inline void MsgQuery::set_opt(const ::std::string& value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void MsgQuery::set_opt(const char* value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void MsgQuery::set_opt(const char* value, size_t size) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgQuery::mutable_opt() {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  return opt_;
}
inline ::std::string* MsgQuery::release_opt() {
  clear_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_;
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgQuery::set_allocated_opt(::std::string* opt) {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    delete opt_;
  }
  if (opt) {
    set_has_opt();
    opt_ = opt;
  } else {
    clear_has_opt();
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MsgResp

// required int64 msg_id = 1;
inline bool MsgResp::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgResp::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgResp::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgResp::clear_msg_id() {
  msg_id_ = GOOGLE_LONGLONG(0);
  clear_has_msg_id();
}
inline ::google::protobuf::int64 MsgResp::msg_id() const {
  return msg_id_;
}
inline void MsgResp::set_msg_id(::google::protobuf::int64 value) {
  set_has_msg_id();
  msg_id_ = value;
}

// required int32 code = 2;
inline bool MsgResp::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgResp::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgResp::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgResp::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 MsgResp::code() const {
  return code_;
}
inline void MsgResp::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// MsgNotify

// required int32 msg_count = 1;
inline bool MsgNotify::has_msg_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgNotify::set_has_msg_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgNotify::clear_has_msg_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgNotify::clear_msg_count() {
  msg_count_ = 0;
  clear_has_msg_count();
}
inline ::google::protobuf::int32 MsgNotify::msg_count() const {
  return msg_count_;
}
inline void MsgNotify::set_msg_count(::google::protobuf::int32 value) {
  set_has_msg_count();
  msg_count_ = value;
}

// repeated .eglcomet.Msg msg_content = 2;
inline int MsgNotify::msg_content_size() const {
  return msg_content_.size();
}
inline void MsgNotify::clear_msg_content() {
  msg_content_.Clear();
}
inline const ::eglcomet::Msg& MsgNotify::msg_content(int index) const {
  return msg_content_.Get(index);
}
inline ::eglcomet::Msg* MsgNotify::mutable_msg_content(int index) {
  return msg_content_.Mutable(index);
}
inline ::eglcomet::Msg* MsgNotify::add_msg_content() {
  return msg_content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eglcomet::Msg >&
MsgNotify::msg_content() const {
  return msg_content_;
}
inline ::google::protobuf::RepeatedPtrField< ::eglcomet::Msg >*
MsgNotify::mutable_msg_content() {
  return &msg_content_;
}

// -------------------------------------------------------------------

// ReqCheckTokenByID

// required int64 id = 1;
inline bool ReqCheckTokenByID::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCheckTokenByID::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCheckTokenByID::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCheckTokenByID::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ReqCheckTokenByID::id() const {
  return id_;
}
inline void ReqCheckTokenByID::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
}

// required string token = 2;
inline bool ReqCheckTokenByID::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCheckTokenByID::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCheckTokenByID::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCheckTokenByID::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqCheckTokenByID::token() const {
  return *token_;
}
inline void ReqCheckTokenByID::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqCheckTokenByID::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqCheckTokenByID::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCheckTokenByID::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ReqCheckTokenByID::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCheckTokenByID::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RspCheckTokenByID

// required int32 rescode = 1;
inline bool RspCheckTokenByID::has_rescode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspCheckTokenByID::set_has_rescode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspCheckTokenByID::clear_has_rescode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspCheckTokenByID::clear_rescode() {
  rescode_ = 0;
  clear_has_rescode();
}
inline ::google::protobuf::int32 RspCheckTokenByID::rescode() const {
  return rescode_;
}
inline void RspCheckTokenByID::set_rescode(::google::protobuf::int32 value) {
  set_has_rescode();
  rescode_ = value;
}

// required string resmsg = 2;
inline bool RspCheckTokenByID::has_resmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspCheckTokenByID::set_has_resmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspCheckTokenByID::clear_has_resmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspCheckTokenByID::clear_resmsg() {
  if (resmsg_ != &::google::protobuf::internal::kEmptyString) {
    resmsg_->clear();
  }
  clear_has_resmsg();
}
inline const ::std::string& RspCheckTokenByID::resmsg() const {
  return *resmsg_;
}
inline void RspCheckTokenByID::set_resmsg(const ::std::string& value) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(value);
}
inline void RspCheckTokenByID::set_resmsg(const char* value) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(value);
}
inline void RspCheckTokenByID::set_resmsg(const char* value, size_t size) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspCheckTokenByID::mutable_resmsg() {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  return resmsg_;
}
inline ::std::string* RspCheckTokenByID::release_resmsg() {
  clear_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resmsg_;
    resmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RspCheckTokenByID::set_allocated_resmsg(::std::string* resmsg) {
  if (resmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete resmsg_;
  }
  if (resmsg) {
    set_has_resmsg();
    resmsg_ = resmsg;
  } else {
    clear_has_resmsg();
    resmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqCheckRelationByID

// required int64 fromID = 1;
inline bool ReqCheckRelationByID::has_fromid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCheckRelationByID::set_has_fromid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCheckRelationByID::clear_has_fromid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCheckRelationByID::clear_fromid() {
  fromid_ = GOOGLE_LONGLONG(0);
  clear_has_fromid();
}
inline ::google::protobuf::int64 ReqCheckRelationByID::fromid() const {
  return fromid_;
}
inline void ReqCheckRelationByID::set_fromid(::google::protobuf::int64 value) {
  set_has_fromid();
  fromid_ = value;
}

// required int64 toID = 2;
inline bool ReqCheckRelationByID::has_toid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCheckRelationByID::set_has_toid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCheckRelationByID::clear_has_toid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCheckRelationByID::clear_toid() {
  toid_ = GOOGLE_LONGLONG(0);
  clear_has_toid();
}
inline ::google::protobuf::int64 ReqCheckRelationByID::toid() const {
  return toid_;
}
inline void ReqCheckRelationByID::set_toid(::google::protobuf::int64 value) {
  set_has_toid();
  toid_ = value;
}

// -------------------------------------------------------------------

// RspCheckRelationByID

// required int32 rescode = 1;
inline bool RspCheckRelationByID::has_rescode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspCheckRelationByID::set_has_rescode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspCheckRelationByID::clear_has_rescode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspCheckRelationByID::clear_rescode() {
  rescode_ = 0;
  clear_has_rescode();
}
inline ::google::protobuf::int32 RspCheckRelationByID::rescode() const {
  return rescode_;
}
inline void RspCheckRelationByID::set_rescode(::google::protobuf::int32 value) {
  set_has_rescode();
  rescode_ = value;
}

// required string resmsg = 2;
inline bool RspCheckRelationByID::has_resmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspCheckRelationByID::set_has_resmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspCheckRelationByID::clear_has_resmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspCheckRelationByID::clear_resmsg() {
  if (resmsg_ != &::google::protobuf::internal::kEmptyString) {
    resmsg_->clear();
  }
  clear_has_resmsg();
}
inline const ::std::string& RspCheckRelationByID::resmsg() const {
  return *resmsg_;
}
inline void RspCheckRelationByID::set_resmsg(const ::std::string& value) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(value);
}
inline void RspCheckRelationByID::set_resmsg(const char* value) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(value);
}
inline void RspCheckRelationByID::set_resmsg(const char* value, size_t size) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspCheckRelationByID::mutable_resmsg() {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  return resmsg_;
}
inline ::std::string* RspCheckRelationByID::release_resmsg() {
  clear_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resmsg_;
    resmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RspCheckRelationByID::set_allocated_resmsg(::std::string* resmsg) {
  if (resmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete resmsg_;
  }
  if (resmsg) {
    set_has_resmsg();
    resmsg_ = resmsg;
  } else {
    clear_has_resmsg();
    resmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqPacket

// required int32 mask = 1;
inline bool ReqPacket::has_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPacket::set_has_mask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPacket::clear_has_mask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPacket::clear_mask() {
  mask_ = 0;
  clear_has_mask();
}
inline ::google::protobuf::int32 ReqPacket::mask() const {
  return mask_;
}
inline void ReqPacket::set_mask(::google::protobuf::int32 value) {
  set_has_mask();
  mask_ = value;
}

// required string udi = 2;
inline bool ReqPacket::has_udi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqPacket::set_has_udi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqPacket::clear_has_udi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqPacket::clear_udi() {
  if (udi_ != &::google::protobuf::internal::kEmptyString) {
    udi_->clear();
  }
  clear_has_udi();
}
inline const ::std::string& ReqPacket::udi() const {
  return *udi_;
}
inline void ReqPacket::set_udi(const ::std::string& value) {
  set_has_udi();
  if (udi_ == &::google::protobuf::internal::kEmptyString) {
    udi_ = new ::std::string;
  }
  udi_->assign(value);
}
inline void ReqPacket::set_udi(const char* value) {
  set_has_udi();
  if (udi_ == &::google::protobuf::internal::kEmptyString) {
    udi_ = new ::std::string;
  }
  udi_->assign(value);
}
inline void ReqPacket::set_udi(const char* value, size_t size) {
  set_has_udi();
  if (udi_ == &::google::protobuf::internal::kEmptyString) {
    udi_ = new ::std::string;
  }
  udi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPacket::mutable_udi() {
  set_has_udi();
  if (udi_ == &::google::protobuf::internal::kEmptyString) {
    udi_ = new ::std::string;
  }
  return udi_;
}
inline ::std::string* ReqPacket::release_udi() {
  clear_has_udi();
  if (udi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = udi_;
    udi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqPacket::set_allocated_udi(::std::string* udi) {
  if (udi_ != &::google::protobuf::internal::kEmptyString) {
    delete udi_;
  }
  if (udi) {
    set_has_udi();
    udi_ = udi;
  } else {
    clear_has_udi();
    udi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string action = 3;
inline int ReqPacket::action_size() const {
  return action_.size();
}
inline void ReqPacket::clear_action() {
  action_.Clear();
}
inline const ::std::string& ReqPacket::action(int index) const {
  return action_.Get(index);
}
inline ::std::string* ReqPacket::mutable_action(int index) {
  return action_.Mutable(index);
}
inline void ReqPacket::set_action(int index, const ::std::string& value) {
  action_.Mutable(index)->assign(value);
}
inline void ReqPacket::set_action(int index, const char* value) {
  action_.Mutable(index)->assign(value);
}
inline void ReqPacket::set_action(int index, const char* value, size_t size) {
  action_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPacket::add_action() {
  return action_.Add();
}
inline void ReqPacket::add_action(const ::std::string& value) {
  action_.Add()->assign(value);
}
inline void ReqPacket::add_action(const char* value) {
  action_.Add()->assign(value);
}
inline void ReqPacket::add_action(const char* value, size_t size) {
  action_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqPacket::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqPacket::mutable_action() {
  return &action_;
}

// repeated bytes params = 4;
inline int ReqPacket::params_size() const {
  return params_.size();
}
inline void ReqPacket::clear_params() {
  params_.Clear();
}
inline const ::std::string& ReqPacket::params(int index) const {
  return params_.Get(index);
}
inline ::std::string* ReqPacket::mutable_params(int index) {
  return params_.Mutable(index);
}
inline void ReqPacket::set_params(int index, const ::std::string& value) {
  params_.Mutable(index)->assign(value);
}
inline void ReqPacket::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
}
inline void ReqPacket::set_params(int index, const void* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPacket::add_params() {
  return params_.Add();
}
inline void ReqPacket::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
}
inline void ReqPacket::add_params(const char* value) {
  params_.Add()->assign(value);
}
inline void ReqPacket::add_params(const void* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReqPacket::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReqPacket::mutable_params() {
  return &params_;
}

// required int32 reqNo = 5;
inline bool ReqPacket::has_reqno() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqPacket::set_has_reqno() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqPacket::clear_has_reqno() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqPacket::clear_reqno() {
  reqno_ = 0;
  clear_has_reqno();
}
inline ::google::protobuf::int32 ReqPacket::reqno() const {
  return reqno_;
}
inline void ReqPacket::set_reqno(::google::protobuf::int32 value) {
  set_has_reqno();
  reqno_ = value;
}

// optional int32 chnNo = 6;
inline bool ReqPacket::has_chnno() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqPacket::set_has_chnno() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqPacket::clear_has_chnno() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqPacket::clear_chnno() {
  chnno_ = 0;
  clear_has_chnno();
}
inline ::google::protobuf::int32 ReqPacket::chnno() const {
  return chnno_;
}
inline void ReqPacket::set_chnno(::google::protobuf::int32 value) {
  set_has_chnno();
  chnno_ = value;
}

// optional int32 chnPos = 7;
inline bool ReqPacket::has_chnpos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqPacket::set_has_chnpos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqPacket::clear_has_chnpos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqPacket::clear_chnpos() {
  chnpos_ = 0;
  clear_has_chnpos();
}
inline ::google::protobuf::int32 ReqPacket::chnpos() const {
  return chnpos_;
}
inline void ReqPacket::set_chnpos(::google::protobuf::int32 value) {
  set_has_chnpos();
  chnpos_ = value;
}

// required int32 clientId = 8;
inline bool ReqPacket::has_clientid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqPacket::set_has_clientid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqPacket::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqPacket::clear_clientid() {
  clientid_ = 0;
  clear_has_clientid();
}
inline ::google::protobuf::int32 ReqPacket::clientid() const {
  return clientid_;
}
inline void ReqPacket::set_clientid(::google::protobuf::int32 value) {
  set_has_clientid();
  clientid_ = value;
}

// optional int32 clientPos = 9;
inline bool ReqPacket::has_clientpos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqPacket::set_has_clientpos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqPacket::clear_has_clientpos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqPacket::clear_clientpos() {
  clientpos_ = 0;
  clear_has_clientpos();
}
inline ::google::protobuf::int32 ReqPacket::clientpos() const {
  return clientpos_;
}
inline void ReqPacket::set_clientpos(::google::protobuf::int32 value) {
  set_has_clientpos();
  clientpos_ = value;
}

// optional string clientVer = 10;
inline bool ReqPacket::has_clientver() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReqPacket::set_has_clientver() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReqPacket::clear_has_clientver() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReqPacket::clear_clientver() {
  if (clientver_ != &::google::protobuf::internal::kEmptyString) {
    clientver_->clear();
  }
  clear_has_clientver();
}
inline const ::std::string& ReqPacket::clientver() const {
  return *clientver_;
}
inline void ReqPacket::set_clientver(const ::std::string& value) {
  set_has_clientver();
  if (clientver_ == &::google::protobuf::internal::kEmptyString) {
    clientver_ = new ::std::string;
  }
  clientver_->assign(value);
}
inline void ReqPacket::set_clientver(const char* value) {
  set_has_clientver();
  if (clientver_ == &::google::protobuf::internal::kEmptyString) {
    clientver_ = new ::std::string;
  }
  clientver_->assign(value);
}
inline void ReqPacket::set_clientver(const char* value, size_t size) {
  set_has_clientver();
  if (clientver_ == &::google::protobuf::internal::kEmptyString) {
    clientver_ = new ::std::string;
  }
  clientver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPacket::mutable_clientver() {
  set_has_clientver();
  if (clientver_ == &::google::protobuf::internal::kEmptyString) {
    clientver_ = new ::std::string;
  }
  return clientver_;
}
inline ::std::string* ReqPacket::release_clientver() {
  clear_has_clientver();
  if (clientver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientver_;
    clientver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqPacket::set_allocated_clientver(::std::string* clientver) {
  if (clientver_ != &::google::protobuf::internal::kEmptyString) {
    delete clientver_;
  }
  if (clientver) {
    set_has_clientver();
    clientver_ = clientver;
  } else {
    clear_has_clientver();
    clientver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rsaKeyVer = 11;
inline bool ReqPacket::has_rsakeyver() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReqPacket::set_has_rsakeyver() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReqPacket::clear_has_rsakeyver() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReqPacket::clear_rsakeyver() {
  if (rsakeyver_ != &::google::protobuf::internal::kEmptyString) {
    rsakeyver_->clear();
  }
  clear_has_rsakeyver();
}
inline const ::std::string& ReqPacket::rsakeyver() const {
  return *rsakeyver_;
}
inline void ReqPacket::set_rsakeyver(const ::std::string& value) {
  set_has_rsakeyver();
  if (rsakeyver_ == &::google::protobuf::internal::kEmptyString) {
    rsakeyver_ = new ::std::string;
  }
  rsakeyver_->assign(value);
}
inline void ReqPacket::set_rsakeyver(const char* value) {
  set_has_rsakeyver();
  if (rsakeyver_ == &::google::protobuf::internal::kEmptyString) {
    rsakeyver_ = new ::std::string;
  }
  rsakeyver_->assign(value);
}
inline void ReqPacket::set_rsakeyver(const char* value, size_t size) {
  set_has_rsakeyver();
  if (rsakeyver_ == &::google::protobuf::internal::kEmptyString) {
    rsakeyver_ = new ::std::string;
  }
  rsakeyver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqPacket::mutable_rsakeyver() {
  set_has_rsakeyver();
  if (rsakeyver_ == &::google::protobuf::internal::kEmptyString) {
    rsakeyver_ = new ::std::string;
  }
  return rsakeyver_;
}
inline ::std::string* ReqPacket::release_rsakeyver() {
  clear_has_rsakeyver();
  if (rsakeyver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rsakeyver_;
    rsakeyver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqPacket::set_allocated_rsakeyver(::std::string* rsakeyver) {
  if (rsakeyver_ != &::google::protobuf::internal::kEmptyString) {
    delete rsakeyver_;
  }
  if (rsakeyver) {
    set_has_rsakeyver();
    rsakeyver_ = rsakeyver;
  } else {
    clear_has_rsakeyver();
    rsakeyver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RspPacket

// required int32 mask = 1;
inline bool RspPacket::has_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspPacket::set_has_mask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspPacket::clear_has_mask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspPacket::clear_mask() {
  mask_ = 0;
  clear_has_mask();
}
inline ::google::protobuf::int32 RspPacket::mask() const {
  return mask_;
}
inline void RspPacket::set_mask(::google::protobuf::int32 value) {
  set_has_mask();
  mask_ = value;
}

// required int32 rescode = 2;
inline bool RspPacket::has_rescode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspPacket::set_has_rescode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspPacket::clear_has_rescode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspPacket::clear_rescode() {
  rescode_ = 0;
  clear_has_rescode();
}
inline ::google::protobuf::int32 RspPacket::rescode() const {
  return rescode_;
}
inline void RspPacket::set_rescode(::google::protobuf::int32 value) {
  set_has_rescode();
  rescode_ = value;
}

// required string resmsg = 3;
inline bool RspPacket::has_resmsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RspPacket::set_has_resmsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RspPacket::clear_has_resmsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RspPacket::clear_resmsg() {
  if (resmsg_ != &::google::protobuf::internal::kEmptyString) {
    resmsg_->clear();
  }
  clear_has_resmsg();
}
inline const ::std::string& RspPacket::resmsg() const {
  return *resmsg_;
}
inline void RspPacket::set_resmsg(const ::std::string& value) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(value);
}
inline void RspPacket::set_resmsg(const char* value) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(value);
}
inline void RspPacket::set_resmsg(const char* value, size_t size) {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  resmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPacket::mutable_resmsg() {
  set_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    resmsg_ = new ::std::string;
  }
  return resmsg_;
}
inline ::std::string* RspPacket::release_resmsg() {
  clear_has_resmsg();
  if (resmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resmsg_;
    resmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RspPacket::set_allocated_resmsg(::std::string* resmsg) {
  if (resmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete resmsg_;
  }
  if (resmsg) {
    set_has_resmsg();
    resmsg_ = resmsg;
  } else {
    clear_has_resmsg();
    resmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string action = 4;
inline int RspPacket::action_size() const {
  return action_.size();
}
inline void RspPacket::clear_action() {
  action_.Clear();
}
inline const ::std::string& RspPacket::action(int index) const {
  return action_.Get(index);
}
inline ::std::string* RspPacket::mutable_action(int index) {
  return action_.Mutable(index);
}
inline void RspPacket::set_action(int index, const ::std::string& value) {
  action_.Mutable(index)->assign(value);
}
inline void RspPacket::set_action(int index, const char* value) {
  action_.Mutable(index)->assign(value);
}
inline void RspPacket::set_action(int index, const char* value, size_t size) {
  action_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPacket::add_action() {
  return action_.Add();
}
inline void RspPacket::add_action(const ::std::string& value) {
  action_.Add()->assign(value);
}
inline void RspPacket::add_action(const char* value) {
  action_.Add()->assign(value);
}
inline void RspPacket::add_action(const char* value, size_t size) {
  action_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RspPacket::action() const {
  return action_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RspPacket::mutable_action() {
  return &action_;
}

// repeated bytes params = 5;
inline int RspPacket::params_size() const {
  return params_.size();
}
inline void RspPacket::clear_params() {
  params_.Clear();
}
inline const ::std::string& RspPacket::params(int index) const {
  return params_.Get(index);
}
inline ::std::string* RspPacket::mutable_params(int index) {
  return params_.Mutable(index);
}
inline void RspPacket::set_params(int index, const ::std::string& value) {
  params_.Mutable(index)->assign(value);
}
inline void RspPacket::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
}
inline void RspPacket::set_params(int index, const void* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspPacket::add_params() {
  return params_.Add();
}
inline void RspPacket::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
}
inline void RspPacket::add_params(const char* value) {
  params_.Add()->assign(value);
}
inline void RspPacket::add_params(const void* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RspPacket::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RspPacket::mutable_params() {
  return &params_;
}

// -------------------------------------------------------------------

// RspRsaKey

// required string rsaVer = 1;
inline bool RspRsaKey::has_rsaver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RspRsaKey::set_has_rsaver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RspRsaKey::clear_has_rsaver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RspRsaKey::clear_rsaver() {
  if (rsaver_ != &::google::protobuf::internal::kEmptyString) {
    rsaver_->clear();
  }
  clear_has_rsaver();
}
inline const ::std::string& RspRsaKey::rsaver() const {
  return *rsaver_;
}
inline void RspRsaKey::set_rsaver(const ::std::string& value) {
  set_has_rsaver();
  if (rsaver_ == &::google::protobuf::internal::kEmptyString) {
    rsaver_ = new ::std::string;
  }
  rsaver_->assign(value);
}
inline void RspRsaKey::set_rsaver(const char* value) {
  set_has_rsaver();
  if (rsaver_ == &::google::protobuf::internal::kEmptyString) {
    rsaver_ = new ::std::string;
  }
  rsaver_->assign(value);
}
inline void RspRsaKey::set_rsaver(const char* value, size_t size) {
  set_has_rsaver();
  if (rsaver_ == &::google::protobuf::internal::kEmptyString) {
    rsaver_ = new ::std::string;
  }
  rsaver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspRsaKey::mutable_rsaver() {
  set_has_rsaver();
  if (rsaver_ == &::google::protobuf::internal::kEmptyString) {
    rsaver_ = new ::std::string;
  }
  return rsaver_;
}
inline ::std::string* RspRsaKey::release_rsaver() {
  clear_has_rsaver();
  if (rsaver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rsaver_;
    rsaver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RspRsaKey::set_allocated_rsaver(::std::string* rsaver) {
  if (rsaver_ != &::google::protobuf::internal::kEmptyString) {
    delete rsaver_;
  }
  if (rsaver) {
    set_has_rsaver();
    rsaver_ = rsaver;
  } else {
    clear_has_rsaver();
    rsaver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string rsaKey = 2;
inline bool RspRsaKey::has_rsakey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RspRsaKey::set_has_rsakey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RspRsaKey::clear_has_rsakey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RspRsaKey::clear_rsakey() {
  if (rsakey_ != &::google::protobuf::internal::kEmptyString) {
    rsakey_->clear();
  }
  clear_has_rsakey();
}
inline const ::std::string& RspRsaKey::rsakey() const {
  return *rsakey_;
}
inline void RspRsaKey::set_rsakey(const ::std::string& value) {
  set_has_rsakey();
  if (rsakey_ == &::google::protobuf::internal::kEmptyString) {
    rsakey_ = new ::std::string;
  }
  rsakey_->assign(value);
}
inline void RspRsaKey::set_rsakey(const char* value) {
  set_has_rsakey();
  if (rsakey_ == &::google::protobuf::internal::kEmptyString) {
    rsakey_ = new ::std::string;
  }
  rsakey_->assign(value);
}
inline void RspRsaKey::set_rsakey(const char* value, size_t size) {
  set_has_rsakey();
  if (rsakey_ == &::google::protobuf::internal::kEmptyString) {
    rsakey_ = new ::std::string;
  }
  rsakey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RspRsaKey::mutable_rsakey() {
  set_has_rsakey();
  if (rsakey_ == &::google::protobuf::internal::kEmptyString) {
    rsakey_ = new ::std::string;
  }
  return rsakey_;
}
inline ::std::string* RspRsaKey::release_rsakey() {
  clear_has_rsakey();
  if (rsakey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rsakey_;
    rsakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RspRsaKey::set_allocated_rsakey(::std::string* rsakey) {
  if (rsakey_ != &::google::protobuf::internal::kEmptyString) {
    delete rsakey_;
  }
  if (rsakey) {
    set_has_rsakey();
    rsakey_ = rsakey;
  } else {
    clear_has_rsakey();
    rsakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace eglcomet

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eglcomet::MaskCode>() {
  return ::eglcomet::MaskCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comet_2eproto__INCLUDED
